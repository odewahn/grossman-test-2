<section data-type="chapter">
<h1>Module 4 - Defining and Using Playing Cards</h1>

<p>Since blackjack is a game with playing cards, you now have to tell the Ruby interpreter what it needs to know about them. &nbsp;</p>

<p>To do this you first have to define an object called CARD.&nbsp; This CARD object is a thing that the rest of your blackjack program can use.&nbsp;&nbsp; An object can contain data and methods.&nbsp; Data are just a group of variables related to that object and methods are things that the object can do. &nbsp;</p>

<p>The data for a playing card is:</p>

<ul>
	<li>name
	<ul>
		<li>name of the card as in Ace, Jack, Queen, King, 10, 9, 8, &hellip; 1</li>
	</ul>
	</li>
	<li>suit
	<ul>
		<li>either hearts, clubs, spades or diamonds</li>
	</ul>
	</li>
</ul>

<p>So when we crate a new card it will have a home for these two variables.&nbsp; These will be the <strong>data </strong>associated with each card.&nbsp;</p>

<h1>DEFINE AN OBJECT</h1>

<p>&nbsp;</p>

<p>The following Ruby code defines the <strong>Card</strong> object.&nbsp; Think of the <strong>object</strong> like a design of a playing card and an <strong>instance </strong>as an actual playing card.&nbsp; The object simply says playing cards have a suit and a value and an indicator as to whether or not the card has been played.&nbsp; The actual instance is an actual playing card.&nbsp;&nbsp; The code below in line 1 has the special keyword <strong>class</strong> which tells ruby we are defining an object named <strong>Card.&nbsp;&nbsp; </strong>The special name <strong>attr_accessor </strong>is short for <em>attribute accessor </em>as <em>attribute</em> is another name for a variable associated with an object.&nbsp;&nbsp;&nbsp; Line 2 says you can view the values of the data in&nbsp;the variable <strong>name, </strong><strong>suit, </strong>and <strong>value</strong> once you create an <strong>instance</strong> of this object.&nbsp;</p>

<h1>ASSOCIATE DATA WITH THE OBJECT</h1>

<p>&nbsp;</p>

<pre data-type="programlisting">
class Card
&nbsp;&nbsp;&nbsp; attr_accessor :name, :suit&nbsp; &nbsp;
end

</pre>

<p>Once you have this code, you can launch the interactive ruby interpreter <strong>irb </strong>and get a feel for the object.&nbsp;</p>

<pre data-type="programlisting">
irb(main):005:0&gt;my_first_card = Card.new
=&gt; #&lt;Card:0x007fe259af
irb(main):006:0&gt; my_first_card.name
=&gt; nil
irb(main):007:0&gt; my_first_card.suit 
=&gt; nil
</pre>

<p>In this example with the Ruby interpreter, line 1 assigns the variable <strong>my_first_card </strong>to be an instance of the <strong>Card </strong>object.&nbsp; The keyword <strong>new </strong>tells the Ruby interpreter to create a new instance of this object.</p>

<p>To display the variable of a particular instance of an object we use the form <strong><em>instance.variable.&nbsp; </em></strong></p>

<p>Next in line 3 the statement <strong>my_first_card.name&nbsp; </strong>says to display the <strong>name </strong>variable of the object associated with <strong>my_first_card.&nbsp;&nbsp; </strong>The ruby interpreter recognizes that <strong>my_first_card </strong>is an instance of the <strong>Card </strong>object and looks up the value of <strong>name </strong>for this instance.&nbsp;&nbsp; In this case it returns <strong>nil </strong>as it has not been assigned.&nbsp; Similarly, line 5 requests <strong>my_first_card.suit </strong>which is also <strong>nil.&nbsp; </strong></p>

<h1>INITIALIZE AN OBJECT</h1>

<p>So the object we just looked at with the statement <strong>x&nbsp; = Card.new </strong>ended up with a card object being assigned to the <strong>x, </strong>but the values of <strong>name </strong>and <strong>suit </strong>were empty (e.g.; <strong>nil)</strong></p>

<h1>Initializing a Playing Card</h1>

<p>&nbsp;</p>

<p>To play blackjack, you need to be able to create a card like the King of Spades.&nbsp; To do this, use the<strong> initialize </strong>method for the object.</p>

<pre data-type="programlisting">
class Card
&nbsp;&nbsp;&nbsp; attr_accessor :name, :suit&nbsp;&nbsp; &nbsp;

&nbsp;&nbsp;&nbsp; def initialize (name, suit)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @name = name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @suit = suit
&nbsp;&nbsp;&nbsp; end
end
</pre>

<p>Line 4 This is our first <strong>method.&nbsp; </strong>A method is a piece of code that can do something to an object.&nbsp;&nbsp; Once you define a method, the rest of your program&nbsp; that wishes to modify an object uses the method to do it.&nbsp; This makes it so if there are any problems with an object, you know they had to have been caused by one of the objects method.&nbsp; This may not sound like a big deal on a project with only 20-30 lines of Ruby code, but once you get to a project with many thousands of lines of code you will be very grateful to be able to know where to focus your efforts when the program does not work.&nbsp; Line four contains <strong>name </strong>and <strong>suit </strong>in parenthesis ().&nbsp;&nbsp; This is so the calling program can indicate the name and suit at the time of initialization.&nbsp; The value for name and the value for suit may be sent to the initialize method.&nbsp; The variables that are sent to a method are called <em>parameters</em> because the in mathematics the exact definition of a&nbsp; <em>parameter&nbsp; </em>in dictionary.com is:</p>

<blockquote>
<p><em><span class="hwc" id="hotword" name="hotword">a</span> <span class="hwc" id="hotword" name="hotword">constant</span> <span class="hwc" id="hotword" name="hotword">or</span> <span class="hwc" id="hotword" name="hotword">variable</span> <span class="hwc" id="hotword" name="hotword">term</span> <span class="hwc" id="hotword" name="hotword">in</span> <span class="hwc" id="hotword" name="hotword">a</span> <span class="hwc" id="hotword" name="hotword">function</span> <span class="hwc" id="hotword" name="hotword">that</span> <span class="hwc" id="hotword" name="hotword">determines</span> <span class="hwc" id="hotword" name="hotword">the</span> <span class="hwc" id="hotword" name="hotword">specific</span> <span class="hwc" id="hotword" name="hotword">form</span> <span class="hwc" id="hotword" name="hotword">of</span> <span class="hwc" id="hotword" name="hotword">the</span> <span class="hwc" id="hotword" name="hotword">function</span> <span class="hwc" id="hotword" name="hotword">but</span> <span class="hwc" id="hotword" name="hotword">not</span> <span class="hwc" id="hotword" name="hotword">its</span> <span class="hwc" id="hotword" name="hotword">general</span> nature</em></p>
</blockquote>

<p>By sending these parameters to the method Card, you are determining the specific form of a playing card (e.g.; King of Hearts, Ten of Diamonds), not the general form of the card (e.g.; has a name like &quot;King&quot; or &quot;Ten&quot; and a suit).&nbsp; So they are called <em>parameters </em>because that is the word that was already invented that precisely describes what these values that are sent to the <strong>new </strong>method are doing.&nbsp;</p>

<p>The <strong>initialize </strong>method defined in line 3 accepts two parameters:&nbsp; <strong>name and suit.&nbsp; </strong>To create a specific playing card try the following Ruby code:</p>

<pre data-type="programlisting">
class Card
&nbsp;&nbsp;&nbsp; attr_accessor :name, :suit, :value&nbsp;&nbsp; &nbsp;

&nbsp;&nbsp;&nbsp; def initialize (name, suit)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @name = name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @suit = suit
&nbsp;&nbsp;&nbsp; end
end

king_of_spades = Card.new(&quot;King&quot;, &quot;spades&quot;)
puts &quot;King of Spades ==&gt; &quot; + king_of_spades.name + &quot; &quot; + king_of_spades.suit</pre>

<p>The output you get should be:</p>

<p><strong>King of Spades Name ==&gt; King Suit ==&gt;&nbsp; spades</strong></p>

<p>Essentially in lines 1-8 you define the class for the general nature of a playing card and line 7 <strong>instantiates </strong>(e.g.; create an instance of) a playing card called with a name of King and a Suit of Spades.</p>

<p>At this point we can create any type of playing card we want.&nbsp; If we want to create three different playing cards we would do the following:</p>

<p>Try the following:</p>

<pre data-type="programlisting">
king_of_spades = Card.new(&quot;King&quot;, &quot;spades&quot;)
queen_of_hearts = Card.new(&quot;Queen&quot;, &quot;hearts&quot;)
jack_of_diamonds = Card.new(&quot;Jack&quot;, &quot;diamonds&quot;)
</pre>

<p>At least now you know how to create a single playing card and you know a little about what an object is and you know how to use the <strong>class </strong>keyword, the <strong>initialize </strong>keyword and what it means to send parameters to a method.&nbsp;&nbsp; At this point we need to talk about a DECK of playing cards.&nbsp; Once we do that we talk about how to DEAL a playing card and then we are mostly done with the game.&nbsp;</p>

<p>Before we do all that, lets talk about some common mistakes before we move on.&nbsp;</p>

<h1>Common Mistake:&nbsp; Wrong number of parameters</h1>

<p>So we have defined an initialize method that takes two parameters and the Ruby interpreter was happy when we sent it &quot;King&quot; for name and &quot;spades&quot; for suit.</p>

<p>Try sending three parameters as in:</p>

<pre data-type="programlisting">
king_of_spades = Card.new(&quot;King&quot;, &quot;spades&quot;, &quot;extra parameter&quot;)
</pre>

<p>You should get an error message something like this:</p>

<p><strong>ArgumentError: wrong number of arguments (3 for 2)</strong></p>

<p>Sometimes parameters are called <strong>arguments </strong>and so the Ruby interpreter is telling you that you have sent the &quot;wrong number of arguments&quot; and it even tells you it was expecting three and you sent 2 (e.g.; <strong>3 for 2)</strong></p>

<h1>Common Mistake: Missing END statement at the end of a class</h1>

<p>It is very easy to forget the END statement at the end of class.&nbsp; Your code would now look like:&nbsp;</p>

<p>&nbsp;</p>

<pre data-type="programlisting">
class Card
&nbsp;&nbsp;&nbsp; attr_accessor :name, :suit, :value&nbsp;&nbsp; &nbsp;

&nbsp;&nbsp;&nbsp; def initialize (name, suit)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @name = name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @suit = suit
&nbsp;&nbsp;&nbsp; end

king_of_spades = Card.new(&quot;King&quot;, &quot;spades&quot;)
puts &quot;King of Spades Name ==&gt; &quot; + king_of_spades.name + &quot; Suit ==&gt;&nbsp; &quot; + king_of_spades.suit</pre>

<p>Notice after line 7 we have a nice <strong>end </strong>to match up with our definition of the <strong>initialize </strong>method, but we have no additional <strong>end </strong>to end our class definition.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
</section>
