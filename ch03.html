<section xmlns="http://www.w3.org/1999/xhtml" id="core_programming_elements" data-type="chapter" class="pagenumrestart"><h1>Core Programming Elements</h1><aside data-type="sidebar"><h5>In This Chapter</h5><ul><li><p>How to install Ruby and save files</p></li><li><p>Defining variables</p></li><li><p>Data classes (types):</p><ul><li><p>Integer</p></li><li><p>Float</p></li><li><p>String</p></li><li><p>Boolean</p></li></ul></li><li><p>Input and output</p></li><li><p>Common programming errors</p></li></ul></aside><section id="threedot1_introduction" data-type="sect1"><h1>3.1 Introduction</h1><p>The first chapter introduced computer science basics, focusing on
    the concept of algorithms. The second chapter discussed the basic
    components of a computer. Now it is time to introduce core programming
    elements, the most basic tools of programming languages. We will show
    examples of this using the Ruby programming language. These include
    constants and variables of various data types and the process of input and
    output. Also, we will explain common programming errors encountered when
    using the information covered in this chapter.</p></section><section id="threedot2_getting_started" data-type="sect1"><h1>3.2 Getting Started</h1><section id="how_to_install_ruby" data-type="sect2"><h2>How to Install Ruby</h2><p>The time has come for you to begin writing simple programs. Before
      you can do that, you need to install Ruby. This is explained in <a href="#installing_ruby" data-type="xref"/> at the back of the book.</p></section><section id="how_to_save_programs" data-type="sect2"><h2>How to Save Programs</h2><p>The next thing to learn is how to save your work. When writing a
      computer program (informally called <em>code</em>), it is
      often important to be able to save it as a plain text file, which can be
      opened and used later.</p><p>To save a program, you must first open a piece of software that
      allows you to create, save, and edit text files. These programs are
      called <em>text editors</em>, and examples include Notepad,
      Scite (included in the one-click installation of Ruby), and many others
      we discuss in <a href="#writing_code_for_ruby" data-type="xref"/>. For more
      advanced editors, you may want to look into <code>vim</code> and <code>emacs</code>. There is also a version of the
      integrated development environment (IDE) Eclipse that works with Ruby.
      Eclipse includes a plain text editor. Once a text editor is open, be
      sure it is set to save as an unformatted text file
      (<em>FileName.txt</em>). Most word processors, such as Word,
      add special characters for document formatting, so these should not be
      used for writing programs. If special characters are turned off by
      saving the document as a plain text file (<em>.txt</em>),
      you can use various word processing programs, such as Word.</p><p>Now you are ready to write and save programs.</p><div id="ch03note01" data-type="note"><h1>Gem of Wisdom</h1><p>Plain text files (sometimes seen with the extension
        <em>.txt</em>) are stored as a simple sequence of
        characters in memory. For example, files created with Notepad on
        Windows are plain text files. Try to open a Microsoft Word document in
        Notepad and observe the results. Non-plain text files are commonly
        called <em>binary files</em>.</p></div></section></section><section id="threedot3_what_is_a_variablequestion_mar" data-type="sect1"><h1>3.3 What Is a Variable?</h1><p>A <em>variable</em> is a piece of data attached to a
    name. In algebra, a variable like <em>x</em> in the equation
    <em>x</em> = <em>y</em> + 2 indicates that
    <em>x</em> and <em>y</em> can take on many
    different values. In most programming languages, variables are defined
    just as in algebra and can be assigned different values at different
    times. In a computer, they refer to a location in memory. Although this is
    a simple concept, variables are the heart of almost every program you
    write. The Pythagorean theorem is shown in <a href="#pythagorean_theorem" data-type="xref"/>, and it uses three variables:
    <em>A</em>, <em>B</em>, and
    <em>C</em>.</p><figure id="pythagorean_theorem" style="float: 0"><img src="images/cspr_0301.png"/><figcaption>Pythagorean theorem</figcaption></figure><p><em>A</em>, <em>B</em>, and
    <em>C</em> are the variable names, and they each represent a
    number. To create a variable in Ruby, simply use the format
    <em>variable_name</em> = <em>value</em>, where
    <em>variable_name</em> is the name of your variable and
    <em>value</em> is the value you would like it to have. The
    equal sign (=) behaves differently in Ruby from the way it does in
    algebra. In Ruby, = means “assign the RHS (righthand side) to the
    variables in the (LHS) lefthand side.” The code snippet <code>y = x + 2</code> means compute the value of <code>x + 2</code> and store the result into the variable
    <code>y</code>. In algebra, <em>y</em> =
    <em>x</em> + 2 simply explains a relationship between
    variables <em>x</em> and <em>y</em>.</p><p>An easy way to test things in Ruby is with <em>irb</em>
    (once Ruby is properly installed), the Interactive Ruby Shell. Enter
    <code>irb</code> from a command prompt; you can see
    that it is very easy to create variables. The following example shows
    several variables being created and assigned values.</p><pre id="pro_id00001" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; a = 4
=&gt; 4
irb(main):002:0&gt; b = 3
=&gt; 3
irb(main):003:0&gt; c = 5
=&gt; 5</pre><p>This example creates three variables named <em>a</em>,
    <em>b</em>, and <em>c</em> and initializes their
    data to 4, 3, and 5, respectively. While these variables were given simple
    names, variables can be given almost any name you wish. However, it is
    poor style to create variable names that are unclear (e.g.,
    <em>x1</em>, <em>x2</em>,
    <em>zxy</em>). Variable names should explain the data they
    represent. When naming variables, avoid special characters (%, $, #, @,
    etc.) because these characters often carry specific meaning. Also note
    that variables cannot begin with integers. Ruby is case-sensitive, so
    <code>myName</code> is different from <code>myname</code>. Variable names should start with a
    lowercase letter, while constants (to be explained shortly) start with an
    uppercase letter. Additionally, people who write programs tend to be
    concerned about readability. Ruby users tend to name long variables with
    underscores (_). For example, instead of naming a variable <code>primenumber</code> or <code>primeNumber</code>, in Ruby it is named <code>prime_number</code>, although the former are both
    acceptable. This is simply a stylistic pattern, not a <span class="keep-together">requirement</span>.</p><p>A variable refers to a section of memory that has been set aside to
    hold whatever data you specify. Every location in memory has an address
    that can be accessed by a program. Instead of asking you to write a
    program to store the value <em>xx</em> into memory location
    <em>yy</em>, most programming languages allow you to identify
    a variable and assign a value to it. The picture in <a href="#memory_diagram" data-type="xref"/> further illustrates the concept of variables
    and memory. <code>variable_1</code> has a value of 5
    stored at location 10, while <code>variable_2</code>
    is stored at location 20 with a value of 8.</p><figure id="memory_diagram" style="float: 0"><img src="images/cspr_0302.png"/><figcaption>Memory diagram</figcaption></figure><p>Variables store different types of data, not just numbers. They can
    hold user-created data, words, numbers, and more. Depending on what type
    of data the variable is holding, it will have a different <em>data
    type</em>.</p><section id="constants_variables_that_never_change" data-type="sect2"><h2>Constants: Variables That Never Change</h2><p>If a variable does not change, it is called a
      <em>constant</em>. For example, 3.14159 is commonly
      understood as <em>π</em> or simply pi. By creating a
      variable called PI and never changing it, that is, making the variable
      into a constant, one can use PI throughout the program instead of
      repeatedly typing the numeral string. By following this convention,
      fewer errors are likely to occur as this value is only entered one time,
      namely when the constant value is assigned. Typing the value of
      <em>π</em> multiple times might lead to typing errors.
      Furthermore, readability is enhanced. For example, it is far more
      intuitive to describe an algorithm that computes the area of a circle as
      one that squares the radius and multiplies the result by PI than one
      that squares the radius and multiplies by 3.14159. As noted before,
      constant names start with a capital letter, and by convention are all
      uppercase.</p></section><section id="data_types" data-type="sect2"><h2>Data Types</h2><p>Data types indicate the nature of the variable and the range of
      valid values for that variable. Data types also indicate how much memory
      to allocate for each type of data. It is important to know that specific
      types of data have specific sizes in memory. As will be evident later,
      data types also define the meanings of allowed operators.</p><p>Ruby refers to data types as classes. In Ruby, as in other
      object-oriented languages, a class is a description of objects. A
      detailed discussion of objects takes place in <a href="#defining_classes_and_creating_objects" data-type="xref"/>. For now, the
      relevant Ruby classes are Fixnum, Bignum, Float, Boolean, and
      String.</p></section><section id="integer" data-type="sect2"><h2>Integer</h2><p>An <em>integer</em> is defined as any natural number
      (0, 1, 2, . . . ) or its negative (0, -1, -2, . . . ). The integer data
      type is simply a subset of the infinite mathematical integers. In a
      32-bit system, integers range in value from -2,147,483,648 to
      2,147,483,647. Note that if the number of bits used differs, so will the
      range.</p><p>Consider the following:</p><pre id="pro_id00002" data-type="programlisting" data-code-language="ruby">irb(main):01:0&gt; x = 5
=&gt; 5</pre><p>When we type in <code>x = 5</code>, we are
      doing two things. First, we are creating a variable <code>x</code> that stores an integer of the class Fixnum.
      Second, we are assigning the value of 5 to <code>x</code>. In some languages, variables must be
      explicitly assigned to a type before they are used. In Ruby, the class
      of the variable is either explicitly stated or inferred in every
      assignment of the variable. In this case, Ruby infers the Fixnum
      class.</p><p>Imagine creating a huge number, out of the range of supported
      integers:</p><pre id="pro_id00003" data-type="programlisting" data-code-language="ruby">irb(main):02:0&gt; x = 1_000_000_000_000_000
=&gt; 1000000000000000</pre><p>The Bignum class is used by Ruby for very large integers not
      contained within the previously stated integer range. This class enables
      the creation of integers outside the range of those possible in
      Fixnum.</p><div id="ch03note02" data-type="note"><h1>Gem of Wisdom</h1><p>Ruby (along with many other programming languages) does not
        allow commas in numbers. Underscores, however, can be used in their
        place. Use an underscore in place of a comma if you need to mark your
        thousands so that larger numbers are more readable.</p></div></section><section id="float" data-type="sect2"><h2>Float</h2><p>Simply put, a <em>float</em> is a decimal number. In
      Ruby, floats can be defined either with numbers containing a decimal
      place or in scientific notation.</p><pre id="pro_id00004" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; x = 5.0
=&gt; 5.0
irb(main):002:0&gt; x = -3.14159
=&gt; -3.14159
irb(main):003:0&gt; x = 3.5e2
=&gt; 350.0</pre><p>Similar to the integers example, when we execute <code>x = 3.14159</code>, we create a variable <code>x</code> that stores a float. We then assign the
      value of 3.14159 to <code>x</code>. Negative
      values are expressed with a leading negative sign (<code>-</code>).</p><p>For scientific notation, values are expressed in powers of 10
      following the symbol <em>e</em>. Hence,
      3.5<em>e</em>2 indicates 3.5 ×
      10<sup>2</sup> = 350. Very small numbers can be
      represented as negative powers of 10. You may find that the designation
      <em>real</em> is used in other languages to denote
      <em>float</em>.</p></section><section id="strings" data-type="sect2"><h2>Strings</h2><p>Strings are simply one or more characters surrounded by quotes.
      Both double quotes (<code>"</code>) and single
      quotes (<code>'</code>) can be used, but if you
      need to use a single quote inside your string, you must bound your
      string with double quotes (e.g., “The computer said, ‘Hello
      World!’ ”).</p><pre id="pro_id00005" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; x = "hello world"
=&gt; hello world
irb(main):002:0&gt; y = "hello, 'world'"
=&gt; hello, 'world'</pre><p>To store characters (such as letters and symbols), a character
      encoding scheme, as discussed in <a href="#how_does_the_computer_really_work" data-type="xref"/>, is used. For example, to
      encode the English alphabet, we need to represent 26 uppercase letters,
      26 lowercase letters, and a variety of special characters. Using eight
      bits (one byte) per character allows us to encode 256 characters, a
      number more than sufficient to represent English. Each character is
      assigned a unique number from 0 to 255.</p></section><section id="booleans" data-type="sect2"><h2>Booleans</h2><p>Booleans can hold only two different values: <code>true</code> and <code>false</code>. They are sometimes referred to as
      <em>flags</em>.</p><pre id="pro_id00006" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; x = true
=&gt; true
irb(main):002:0&gt; y = false
=&gt; false</pre></section></section><section id="threedot4_basic_arithmetic_operators" data-type="sect1"><h1>3.4 Basic Arithmetic Operators</h1><p>Now that some of the classes that define various data types have
    been introduced, what can you do with them? Like all other programming
    languages, Ruby is able to perform many mathematical operations. In <a href="#basic_arithmetic_operators" data-type="xref"/>, we illustrate how to use Ruby as
    a <span class="keep-together">calculator</span>.</p><table id="basic_arithmetic_operators"><caption>Basic arithmetic operators</caption><thead><tr><th>Symbol</th><th>Operation</th><th>Example</th></tr></thead><tbody><tr><td><p><code>+</code></p></td><td><p>Addition</p></td><td><p><code>x = 6 +
            2</code></p> <p>8</p></td></tr><tr><td><p><code>-</code></p></td><td><p>Subtraction</p></td><td><p><code>x = 3 -
            2</code></p> <p>1</p></td></tr><tr><td><p><code>*</code></p></td><td><p>Multiplication</p></td><td><p><code>x = 5 *
            2</code></p> <p>10</p></td></tr><tr><td><p><code>/</code></p></td><td><p>Division</p></td><td><p><code>x =
            16/8</code></p> <p>2</p></td></tr><tr><td><p><code>%</code></p></td><td><p>Modulus</p></td><td><p><code>x = 5 %
            3</code></p> <p>2</p></td></tr><tr><td><p><code>**</code></p></td><td><p>Power</p></td><td><p><code>x = 2 **
            4</code></p> <p>16</p></td></tr></tbody></table><p>All of the operators listed are binary operators, meaning the
    operator has two operands. For example, the command <code>A + B</code> is a binary operation, where A and B are
    the two operands and + is the operator.</p><p>When typing mathematical operations in the Ruby interpreter, the
    order of operations is taken into account. To change the order of
    operations, use parentheses. Try typing the following in the command
    line:</p><pre id="pro_id00007" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; x = 10 + 4 / 2</pre><p>What result did you get? Now try entering the following into the
    prompt:</p><pre id="pro_id00008" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; x = (10 + 4) / 2</pre><p>Most of the operators should look familiar. The one that might not
    is the modulus operator (<code>%</code>). The
    purpose of this operator is to find the remainder produced by dividing two
    numbers. For example, 4 modulo 2, abbreviated 4 mod 2, would produce the
    result 0. This is because 4 / 2 is exactly 2. On the other hand, 2 mod 4
    produces a result of 2. This is because 2 / 4 is 0, with a remainder of 2.
    Let’s try to solve a few easy problems using the modulus operator.</p><ol><li><p>Using the mod operator, determine if a number is even. This
        should be fairly easy. We know that <em>n</em> is even if,
        when divided by 2, it produces a remainder of 0. So, if
        <em>n</em> mod 2 equals 0, then <em>n</em> is
        even.</p><pre id="pro_id00009" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; x = 5%2
=&gt; 1
irb(main):002:0&gt; x = 6%2
=&gt; 0</pre></li><li><p>Given a number as input, determine if the number is prime. That
        is, the given number must not have any factors other than 1 and
        itself. For example, 1, 3, 5, and 7 are prime numbers. The number 2 is
        the only even prime number since all other even numbers have 2 as a
        factor. Likewise, for example, the number 9 is also not prime since 3
        divides it evenly. As an aside, finding prime numbers is one of the
        classic problems used to teach any programming language. Furthermore,
        prime numbers play a significant role in information security. For
        example, SSL (Secure Sockets Layer), which is what you use when you go
        to a website and type "https", uses an algorithm called public key
        encryption. This algorithm relies heavily on prime numbers. The
        intuition behind the use of prime numbers is that for long numbers
        (those that comprise hundreds of digits) it takes a computer a very
        long time to determine their factors. Thus, it is safe to publicly
        present these numbers.</p><p>Although we may not be able to program this yet, we can come up
        with an algorithm to solve this problem. Namely, we can do the
        following:</p><p>If <em>n</em> is equal to 2, then
        <em>n</em> is prime. Otherwise, take each number
        <em>x</em> in the range 2 to <em>n</em> – 1.
        If <em>n</em> mod <em>x</em> is equal to 0 for
        any of these numbers <em>x</em>, then the number
        <em>n</em> is not prime. If <em>n</em> mod
        <em>x</em> is not equal to 0 for every number in the range
        2 to <em>n</em> – 1, then the number
        <em>n</em> is prime.</p><p>Note that this is not an efficient algorithm, but it is correct.
        Can you think of a more efficient approach? Hint: Do we really need to
        check all the way up to <em>n</em> – 1?</p></li></ol><div id="ch03note03" data-type="note"><h1>Gem of Wisdom</h1><p>Components of a mathematical expression can usually be broken into
      operands and operators. For example, in the expression 2 + 3, 2 and 3
      are operands, and + is the operator. Operands are usually values, and
      operators are the actions to be performed.</p></div><p>Now that we have discussed the basics, we will describe some
    slightly more advanced operations. Ruby has many built-in modules; a
    <em>module</em> is simply a <em>group of
    methods</em> for a particular domain. There are methods that
    accomplish many different tasks. We will discuss methods in great detail
    starting with <a href="#using_objects" data-type="xref"/>. For example, Ruby has a
    built-in module for mathematics, the <code>Math</code> module. <a href="#advanced_arithmetic_operations" data-type="xref"/> lists some of the more
    advanced mathematical functions in Ruby. These functions are referred to
    as <em>methods</em>.</p><table id="advanced_arithmetic_operations"><caption>Advanced arithmetic operations</caption><thead><tr><th>Method</th><th>Operation</th><th>Example</th><th/></tr></thead><tbody><tr><td><p><code>sqrt()</code></p></td><td><p>Square root</p></td><td><p><code>x =
            Math.sqrt(9)</code><br/></p></td><td>3.0</td></tr><tr><td><p><code>sin()</code></p></td><td><p>Sine</p></td><td><p><code>x =
            Math.sin(0)</code><br/></p></td><td>0.0</td></tr><tr><td><p><code>cos()</code></p></td><td><p>Cosine</p></td><td><p><code>x =
            Math.cos(0)</code><br/></p></td><td>1.0</td></tr><tr><td><p><code>tan()</code></p></td><td><p>Tangent</p></td><td><p><code>x =
            Math.tan(0.7854)</code><br/></p></td><td>1.0</td></tr><tr><td><p><code>log()</code></p></td><td><p>Natural log (ln)</p></td><td><p><code>x =
            Math.log(5)</code><br/></p></td><td>1.609</td></tr><tr><td><p><code>log10()</code></p></td><td><p>Log (base 10)</p></td><td><p><code>x =
            Math.log10(10)</code><br/></p></td><td>1.0</td></tr></tbody></table><p>When trying to perform these operations, we specify the <code>Math</code> module, followed by a period (.), then the
    method (type of operation). For example, to find the square root of 16,
    type:</p><pre id="pro_id00010" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; x = Math.sqrt(16)
=&gt; 4.0</pre><p>To appreciate the power of the <code>Math</code> module and understand the order of
    operations in Ruby, try creating a program that performs the following
    operation:</p><div id="ch03equ01" data-type="equation"><math xmlns="http://www.w3.org/1998/Math/MathML">
        <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
          <mml:mrow>
            <mml:mi>x</mml:mi>

            <mml:mo>=</mml:mo>

            <mml:mfrac>
              <mml:mrow>
                <mml:mstyle displaystyle="true" scriptlevel="0">
                  <mml:mrow>
                    <mml:mn>5</mml:mn>

                    <mml:mo>+</mml:mo>

                    <mml:msqrt>
                      <mml:mrow>
                        <mml:mn>9</mml:mn>
                      </mml:mrow>
                    </mml:msqrt>
                  </mml:mrow>
                </mml:mstyle>
              </mml:mrow>

              <mml:mrow>
                <mml:mstyle displaystyle="true" scriptlevel="0">
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                  </mml:mrow>
                </mml:mstyle>
              </mml:mrow>
            </mml:mfrac>
          </mml:mrow>
        </mml:mrow>
      </math></div><p>The result should look similar to this:</p><pre id="pro_id00011" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; x = (5 + Math.sqrt(9)) / 2
=&gt; 4.0</pre><p>Make sure you obtain 4.0 as a result. If you do not, try again. With
    computers there is <em>no point in repeating failure</em>
    precisely. Often, novice programmers state: “Well, I tried it 500 times!”
    If no input was changed, rest assured that no output will change either.
    So <em>change something</em> and then try again! Be patient,
    check things carefully, and keep working until the result is 4.0. If you
    obtained 4.0 the first time, try some variations (e.g., misspell the word
    <em>Math</em>), and become familiar with some error messages.
    It is important to start being methodical about implementing programs on a
    computer on the very first day. Take your time, go slowly, and think about
    everything you enter. Sometimes with programming languages even the
    smallest detail can be the difference between success and failure.</p><div id="ch03note04" data-type="note"><h1>Gem of Wisdom</h1><p>Ruby comes with many built-in functions called
      <em>methods</em> to make your life easier. <a href="#advanced_arithmetic_operations" data-type="xref"/> shows a few of them. Without
      a square root (i.e., <code>sqrt()</code>) function
      you would need to write a program to compute the square root by repeated
      division. For any programming language, make sure you learn about all
      the built-in functions, as they can save you significant time.</p></div></section><section id="threedot5_input_and_output" data-type="sect1"><h1>3.5 Input and Output</h1><section id="output_using_variables" data-type="sect2"><h2>Output Using Variables</h2><p>Displaying text in Ruby is simple. Try entering the following at
      the command prompt:</p><pre id="pro_id00012" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; puts "Hello World"</pre><p>The <code>puts</code> method (short for
      outPUT a String) simply displays a string on the screen. Notice the
      string is contained in quotation marks; otherwise, both <code>Hello</code> and <code>World</code> would be interpreted as variables.
      Variables are displayed on the screen using similar syntax, except
      without quotation marks:</p><pre id="pro_id00013" data-type="programlisting" data-code-language="ruby">irb(main):002:0&gt; text = "Hello World"
=&gt; "Hello World"
irb(main):003:0&gt; puts text
=&gt; Hello World</pre><p>This example stores the string <code>“Hello
      World”</code> in a variable named <code>text</code> and then displays the value stored in the
      <code>text</code> variable using the <code>puts</code> method. This method is not limited to
      strings and can be used with other classes including integers, floats,
      and Booleans.</p><p>The use of classes to define data types means a variety of methods
      can be done for each type. For example, <code>x.length</code> indicates the size of a string when
      <code>x</code> is defined as a string.</p></section><section id="display_user_input" data-type="sect2"><h2>Display User Input</h2><p>Displaying user input in Ruby is almost as easy as displaying
      output. Try entering the following in the command prompt:</p><pre id="pro_id00014" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; age_input = gets</pre><p>The <code>gets</code> method (short for GET
      a String from the user) stops the program and waits for the user to type
      some text and then press Enter. The text typed by the user will be
      stored as a string in a variable called <code>age_input</code>. Due to the nature of the <code>gets</code> method, the value stored in <code>age_input</code> will be a string, but you need an
      integer if you wish to mathematically manipulate it. We create another
      variable <code>age</code> and set it equal to the
      integer value of the user’s input by converting the string <code>age_input</code> to an integer. This is done by
      issuing the following command:</p><pre id="pro_id00015" data-type="programlisting" data-code-language="ruby">irb(main):002:0&gt; age = age_input.to_i</pre><p>The method <code>to_i</code> converts
      <code>age_input</code> to an integer.</p></section><section id="basic_programs" data-type="sect2"><h2>Basic Programs</h2><p>Now that you have learned how to display text and request user
      input, you can develop a program that calculates the area of a
      rectangle. Try using the problem-solving approach discussed in <a href="#introduction_to_computer_science" data-type="xref"/> to create this
      program.</p></section><section id="step_1_understanding_the_problem-id00002" data-type="sect2"><h2>Step 1: Understanding the Problem</h2><p>Ask yourself key questions that must be answered to properly
      design the program:</p><ul><li><p>How do you find the area of a rectangle?</p></li><li><p>How many variables do you need to represent that area?</p></li><li><p>What data type do the variables need to be?</p></li></ul></section><section id="step_2_write_out_the_problem_in_plain_la" data-type="sect2"><h2>Step 2: Write Out the Problem in Plain Language</h2><p>Before writing out the problem, remember that the input method
      stores user input as strings, so we need to convert the lengths (which
      are stored as strings) to integers before performing mathematical
      operations with them.</p><ol><li><p>Ask for the length.</p></li><li><p>Store the length.</p></li><li><p>Ask for the width.</p></li><li><p>Store the width.</p></li><li><p>Convert the length to an integer.</p></li><li><p>Convert the width to an integer.</p></li><li><p>Calculate rectangle area (area = length × width).</p></li><li><p>Display area.</p></li></ol><p>The equation for the area of a rectangle is the product of its
      length and width. Although it does not affect this equation, remember
      that the rules for order of operations apply in Ruby. To change the
      order of operations, use parentheses.</p></section><section id="step_3_rewrite_the_plain_language_into_c" data-type="sect2"><h2>Step 3: Rewrite the Plain Language into Code</h2><p>See <a href="#code_with_comments" data-type="xref"/>. In the figure, as with
      all other program illustrations, the line numbers are not part of the
      code; they are added strictly for explanatory purposes. In line 8, we
      are printing an integer represented in the variable <code>area</code>. This differs from the printing of
      character strings in lines 1 and 3. Ruby automatically determines the
      data type, if it can. This is called dynamic or “duck” typing. This
      functionality is helpful; however, as you will see, automatic type
      determination can introduce problems. In this example, though, it helps
      in that <code>puts area</code> is mapped to
      <code>puts area.to_s</code>. Note that generally
      speaking, the <code>.to_*</code> method is a type
      conversion operation where the target type is represented by the
      <code>*</code> (a wildcard). For example, you have
      now seen conversion to integer (<code>to_i</code>)
      and to string (<code>to_s</code>).</p><div id="code_with_comments" data-type="example"><h5>Code with comments</h5><pre data-type="programlisting" data-code-language="ruby">    1 puts "What is the length?"	# Ask for the length 
    2 length_input = gets		# Stores the length 
    3 puts "What is the width?"	# Ask for the width 
    4 width_input = gets		# Stores the width 
    5 length  = length_input.to_i	# Convert length to integer 
    6 width = width_input.to_i	# Convert width to integer 
    7 area = length * width		# Calculate rectangle area 
    8 puts area			# Display area 
</pre></div></section><section id="step_4_test_the_code_in_the_comp-id00003" data-type="sect2"><h2>Step 4: Test the Code in the Computer</h2><p>Similarly those who are adventurous can type the code lines from
      step 3 into a file and run the code from there. For those who are
      unsure, no worries; we address files later on. For now, simply see if
      you get the desired results; if not, make sure you typed <span class="keep-together">everything</span> correctly.</p><p>If it works, congratulations! You have just created a program that
      calculates the area of a rectangle.</p></section></section><section id="threedot6_common_programming_errors" data-type="sect1"><h1>3.6 Common Programming Errors</h1><section id="syntax_errors" data-type="sect2"><h2>Syntax Errors</h2><p>As a programmer, it is important for you to become comfortable
      with error messages. Even the most experienced computer programmers will
      have a typo or forget a quotation mark regularly. When you first start,
      error messages will seem incomprehensible. Later, they will help you fix
      the problem quickly.</p><div id="ch03note05" data-type="note"><h1>Gem of Wisdom</h1><p>When you get an error message, do not just try the program
        again. This may work with your toaster, where you just unplug it and
        plug it back in, but with software development, it rarely, if ever,
        works. Figure out the problem, make a correction, and then see if it
        works.</p></div><p>Try the following command in <code>irb</code>:</p><pre id="pro_id00016" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; x = 1 + "hello"
TypeError: String can't be coerced into Fixnum
     from (irb):1:in '+'
     from (irb):1</pre><p>Syntax errors refer to code that Ruby cannot actually execute.
      Since it does not make sense for Ruby to add an integer to a string, it
      stops execution and informs you of the location where it had to
      stop.</p><p>Let’s move on to a more realistic example. When entering strings,
      we are likely to forget quotes once in a while.</p><pre id="pro_id00017" data-type="programlisting" data-code-language="ruby">irb(main):002:0&gt; x = hello
NameError: undefined local variable or method 'hello' for
main:Object
from (irb):2</pre><p>Wait! Why does the Ruby interpreter not just tell us that we
      forgot quotes? Ruby must guess what we intended. All Ruby knows is that
      we tried assigning <code>hello</code> to <code>x</code>. Since any string not contained in quotes is
      the name of a variable or a command, Ruby tries to find the value stored
      in a variable named <code>hello</code>. Since Ruby
      cannot find any variable named <code>hello</code>,
      it prints an error. It is important to start viewing code in terms of
      how Ruby might interpret it, but this is a skill that will take time to
      develop. Meanwhile, realize that errors will happen, and expect to be
      learning from them.</p></section><section id="logic_errors" data-type="sect2"><h2>Logic Errors</h2><p>Errors that Ruby cannot catch are logic errors. They are problems
      with a program that cause it to return the wrong or undesired result.
      For example, if you are trying to find the area of a rectangle, but you
      multiplied the height by itself instead of by the width, that would be a
      logic error.</p><p>The Ruby interpreter, the program that executes the Ruby
      instructions input by the user, does not try to guess that we meant to
      use a different variable. Logic errors are often much harder to trace
      than syntax errors because of this. To avoid them, it is often useful to
      look at your program and “play computer.” That is, pretend that you are
      the Ruby interpreter, and follow the steps that will be implemented as
      the program is executed. From this point on, we’ll use the words
      <em>Ruby</em> and <em>Ruby interpreter</em>
      interchangeably.</p><div id="ch03note06" data-type="note"><h1>Gem of Wisdom</h1><p>Truncation refers to limiting the number of significant digits
        by discarding extra digits. Unlike rounding, truncation simply throws
        the extra digits away.</p></div><p>A more common error involves integer division. Arithmetic
      expressions that operate on integers will always evaluate to integer
      form. This happens even with division, where the result would otherwise
      be a decimal. Ruby does this by truncating the arithmetic result
      (chopping off the decimal place and all the digits to the right of it).
      For example, 5 divided by 2 will evaluate to 2 instead of to 2.5.</p><pre id="pro_id00018" data-type="programlisting" data-code-language="ruby">irb(main):003:0&gt; 5 / 2
=&gt; 2</pre><p>If you get a wrong value using this computation in a program, then
      your final result will likely be erroneous, too.</p></section></section><section id="threedot7_mixing_data_types" data-type="sect1"><h1>3.7 Mixing Data Types</h1><p>Ruby will always try to remain in the same data type as its
    operands. For example, if the integers 2 and 3 are added in Ruby, the
    result will also be an integer.</p><pre id="pro_id00019" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; 2 + 3
=&gt; 5</pre><p>Likewise, when adding two floats, the result will also be a
    float.</p><pre id="pro_id00020" data-type="programlisting" data-code-language="ruby">irb(main):002:0&gt; 2.0 + 3.0
=&gt; 5.0</pre><p>When Ruby encounters two operands of different data types, it will
    convert them to match where possible.</p><pre id="pro_id00021" data-type="programlisting" data-code-language="ruby">irb(main):003:0&gt; 2 + 3.0
=&gt; 5.0</pre><p>The issue of dividing integers like 5 / 2 can finally be resolved.
    We are able to force Ruby to convert integer expressions into float
    expressions. Simply throw a float into the mix.</p><pre id="pro_id00022" data-type="programlisting" data-code-language="ruby">irb(main):004:0&gt; 1.0 * 5 / 2
=&gt; 2.5</pre><p>Of course, it is sometimes impossible to convert the data types to
    match. In this case, Ruby will output a <code>TypeError</code>.</p><pre id="pro_id00023" data-type="programlisting" data-code-language="ruby">irb(main):005:0&gt; x = 1 + "hello"
TypeError: String can't be coerced into Fixnum
     from (irb):4:in '+'
     from (irb):4</pre></section><section id="threedot8_summary" data-type="sect1"><h1>3.8 Summary</h1><p>We discussed classes, variables, constants, and key data types such
    as strings and integers. At this point, you should know how to create a
    variable in Ruby and how to assign values to your newly created
    variable.</p><section id="threedot8dot1_key_concepts" data-type="sect2"><h2>3.8.1 Key Concepts</h2><ul><li><p>Ruby programs can be created/edited in any text editor (as
          defined previously), so long as the editor can save files as plain
          text. It is <em>highly</em>
          recommended that you use an editor suited for writing
          programs.</p></li><li><p>When naming <em>variables</em>, it is a common
          practice to separate each word in a variable name with an underscore
          (_).</p></li><li><p>Programming languages use various data types to perform
          various operations. Ruby uses many data types, including
          <em>integer</em> (<em>Fixnum</em> and
          <em>Bignum</em>), <em>float</em>,
          <em>string</em>, and
          <em>Boolean</em>.</p></li><li><p>It is important to understand the syntax behind simple
          mathematical operators. Mathematical operators will often be used
          when programming. Pay attention to the order of operation.</p></li><li><p>To output information onto the screen, use the <code>puts</code> command. To input information from
          the user, use the <code>gets</code>
          command.</p></li><li><p>The three types of programming errors are <em>syntax
          errors</em>, <em>logic errors</em>, and
          <em>type errors</em>. Type errors often arise from
          mixing data types that cannot be mixed, such as integers and
          strings.</p></li><li><p><em>Conversion errors</em> are a subset of
          <em>type errors</em>.</p></li></ul></section><section id="threedot8dot2_key_definitions" data-type="sect2"><h2>3.8.2 Key Definitions</h2><ul><li><p><em>Variable</em>: A piece of data attached to a
          name, class, and memory location.</p></li><li><p><em>Instantiate</em>: In this simple initial
          presentation, creating a variable. See <a href="#defining_classes_and_creating_objects" data-type="xref"/> for more
          information.</p></li><li><p><em>Constant</em>: A variable that is set once and
          never changed.</p></li><li><p><em>Initialize</em>: To assign a value to a
          variable when the variable is created.</p></li><li><p><em>Data class</em>: Information about the
          variable that defines the possible values a variable can have and
          what operations can be performed using it. A more complete
          description is presented in <a href="#using_objects" data-type="xref"/>.</p></li><li><p><em>Integer</em>: A class that defines a whole
          number. Ruby recognizes two classes:</p><ul><li><p><em>Fixnum</em>: An integer with a limited
              range. In 32-bit systems, the range <span class="keep-together">–2,147,483,648 to
              2,147,483,647.</span></p></li><li><p><em>Bignum</em>: An integer outside the range
              of Fixnum.</p></li></ul></li><li><p><em>Float</em>: A class that defines a decimal
          number.</p></li><li><p><em>String</em>: A class that defines a sequence
          of characters.</p></li><li><p><em>Boolean</em>: A class that defines a value of
          either <code>true</code> or <code>false</code>.</p></li><li><p><em>Syntax errors</em>: Errors produced by
          incorrect syntax for the programming language.</p></li><li><p><em>Logic errors</em>: Errors produced by bad
          logic.</p></li><li><p><em>Type errors</em>: Errors produced by mixing
          data types that cannot be mixed.</p></li></ul></section></section><?hard-pagebreak?><section id="threedot9_exercises" data-type="sect1"><h1>3.9 Exercises</h1><ol class="qonly"><li><p>You saw that Ruby does not allow addition of floats and strings.
        For example:</p><pre id="pro_id00024" data-type="programlisting" data-code-language="ruby">irb(main):005:0&gt; 1.1 + "string"
TypeError: String can't be coerced into Float
     from /Users/leland/.irbrc:73(irb):1:in '+'
     from (irb):14</pre><p>What type combinations does Ruby allow to be added?</p></li><li><p>Using <code>irb</code>, initialize three
        variables, <code>x</code>, <code>y</code>, and <code>z</code>,
        each to some number less than 10. Design an equation with these
        variables using at least one multiplication, one division, and one
        addition or subtraction element. Have the computer do it once without
        parentheses, and then add parentheses to the equation and try it
        again. Are the answers the same? If not, why not?</p></li><li><p>Earlier in the chapter, we saw the following:</p><pre id="pro_id00025" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; 1.0 * 5 / 2
=&gt; 2.5</pre><p>Now, try typing the following code into <code>irb</code>:</p><pre id="pro_id00026" data-type="programlisting" data-code-language="ruby">irb(main):002:0&gt; 5 / 2*1.0</pre><p>This should have produced a value of 2.0. Why does it produce
        the value 2.0, and not 2.5, like we saw earlier?</p></li><li><p>Write the expected value of <code>x</code>
        after both lines are executed.</p><ol type="a"><li><pre id="pro_id00027" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; x = 9
irb(main):002:0&gt; x = x/2</pre></li><li><pre id="pro_id00028" data-type="programlisting" data-code-language="ruby">irb(main):003:0&gt; x = 9
irb(main):004:0&gt; x = x/2.0</pre></li></ol></li><li><p>What is the expected result of <code>c</code> for each code group?</p><ol type="a"><li><pre id="pro_id00029" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; a = Math.sqrt(9)
irb(main):002:0&gt; b = 2
irb(main):003:0&gt; c = a/b</pre></li><li><pre id="pro_id00030" data-type="programlisting" data-code-language="ruby">irb(main):001:0&gt; a = 5
irb(main):002:0&gt; b = 2
irb(main):003:0&gt; c = a/b</pre></li></ol></li><li><p>Suppose a program finds the average temperature for a given
        year. A user of the program is prompted to enter the average
        temperature values for each season of the year: winter, spring,
        summer, and fall. The program stores these values as floats in
        variables <code>temp_winter</code>, <code>temp_spring</code>, <code>temp_summer</code>, and <code>temp_fall</code>, respectively. The final result is
        stored in the variable <code>avg_temp</code>.
        The program calculates the average temperature with the following
        line:</p><pre id="pro_id00031" data-type="programlisting" data-code-language="ruby">avg_temp = temp_winter + temp_spring + temp_summer + temp_f/4</pre><p>However, when the program runs, the value of <code>avg_temp</code> is always incorrect. Briefly
        describe what is wrong with this line and what changes you would make
        to correct this error.</p></li><li><p>What is the difference between logic and syntax errors? Give an
        example of each.</p></li></ol></section></section>