<section class="pagenumrestart" data-type="chapter" id="introduction_to_computer_science" xmlns="http://www.w3.org/1999/xhtml">
<aside data-type="sidebar">
<h5>Amusing Digression</h5>

<p>Once upon a time, we worked in a computer lab helping students with their programming problems. &nbsp;There was a keypunch machine in the room to make punched cards which were submitted to computers. &nbsp; Students would stick chewing gum in the keypunch machine to help retrieve stuck cards. &nbsp; Our job at the end of day was to clean the lab and clean out all the chewing gum. &nbsp;SO just remember, however bad your life might be -- at least you aren't cleaning out used chewing gum. &nbsp;</p>
</aside>

<h1>Introduction to Computer Science</h1>

<aside data-type="sidebar">
<h5>In This Chapter</h5>

<ul>
	<li>
	<p>Defining computer science</p>
	</li>
	<li>
	<p>Define Programming</p>
	</li>
	<li>
	<p>Define Blackjack, the game we will be writing all course</p>
	</li>
	<li>
	<p>Define how we are doing this course (US Master, you apprentice)</p>
	</li>
	<li>
	<p>Teach you how to do something -- output the rules of blackjack</p>
	</li>
	<li>
	<p>Show you how to break what you just did and then fix it so you start to get the hang of how to get something to work</p>
	</li>
	<li>
	<p>Introduce the idea of methods</p>
	</li>
	<li>
	<p>introduce the idea of data types</p>
	</li>
	<li>
	<p>introduce the idea of variables</p>
	</li>
</ul>
</aside>

<section data-type="sect1" id="onedot1_what_is_computer_sciencequestion">
<h1>1.1 Introduction</h1>

<p>Computers only do useful or fun things because they run programs.&nbsp;Computer programs are sets of instructions that are given to the computer. &nbsp;They are fairly precise. &nbsp;If you mis-spell a word the computer won't understand what you meant. &nbsp;If you add an extra comma somewhere its not like your English teacher will just circle it and move on. &nbsp;Your program won't work.</p>

<p>Hence, new people to computer programming often struggle just to get the basics working. &nbsp;They usually have to set up a whole programming environment which is often a barrier to learning. &nbsp;With this course, you just click on things and enter some answers and POOF you are writing a computer program.&nbsp;</p>

<p>It turns out there is a whole SCIENCE to studying how to really make a computer solve problems. &nbsp;That is called Computer Science&nbsp; and not Computer Programming. &nbsp;Why? &nbsp;While, it turns out you can study and compare different ways of getting the computer to do something and you can mathematically figure out the best way to do things. &nbsp;So if &nbsp;all you do is get computer programs to work you may miss out on some good lessons learned from people who have studied this for the past fifty years. &nbsp; Think about planting crops. &nbsp;You can do it with a shovel or you can use a tractor. &nbsp;If you are in a world where you haven't even heard of a tractor and all you have is a shovel you might resign yourself to digging the dirt shovel by shovel. &nbsp;One day you'll learn about the tractor and say WOW -- sure wish I had known about that tractor before I spend 30 days in the heat shoveling this field! &nbsp;</p>

<p>So once you get the basics of Computer programming its awfully good to start to learn about computer science and learn what tractors have been developed that will make your life significantly easier. &nbsp;Computer Science also provides ways to solve problems so when faced with a new problem, you will not just throw up your hands, you will have a methodical approach to solving it. &nbsp; So we want you to learn not just computer programming but we want you to learn a little Computer Science as well. &nbsp;</p>

<p>Computer Science is all about concepts and approaches needed to solve problems using a computer. &nbsp;Computer Programming is just about writing a program in a particular programming language. &nbsp;People who just get a program to work in a given language are often fine, but well then, due to various reasons different programming languages become popular. &nbsp;Primarily because Computer Scientists are always trying to come up with new programming languages that will make life easier for programmers. &nbsp;So lets say you decide Ruby (the language we have picked for this course because its so super easy to get started) and then ten years from now some other language comes along that you've never heard of. &nbsp;IF you have the basics of Computer Science in your head, well then you know that the language is just a tool (e.g.; like a shovel, like a tractor) and you adapt quickly because you will know the common things the tool should be able to do and how it will probably work. &nbsp;If you have ignored Computer Science you will thing OH GOODNESS -- how I am to start ALL OVER and LEARN a WHOLE NEW LANGUAGE. &nbsp;</p>

<p>So that's why we harp on teaching some Computer Science along the way with teaching Ruby.&nbsp;</p>

<p>We've decided to try something new with this course. &nbsp; A typical course would teach you all the different commands you might use when programming in Ruby. &nbsp;Then it would start to put them together. &nbsp;We've decided that's too boring and its not so great because if we give you a list of ten commands and you don't use them right away - well you'll probably forget at least a couple of them along the way. &nbsp;Then when we want to use them you'll be lost. &nbsp;So it is for most students taking a course that covers a programming language -- we know as we have taught for over 25 years.&nbsp;</p>

<p>So lets try something new. &nbsp;Lets pretend we are the master and you are the apprentice and lets say we are building a house. &nbsp; If we need you to hammer a nail we say HEY APPRENTICE, come HAMMER THIS NAIL NOW! &nbsp; You have never hammered one. &nbsp;You look blankly at us. &nbsp;We shrug and moan about the troubles with new apprentices. &nbsp;We then pick up a hammer and hammer a nail. &nbsp;We look at you and say GOT IT? &nbsp;You nod and then pick up the hammer the wrong way. &nbsp;We sigh and moan and say NOT THAT WAY, THIS WAY. &nbsp;Then you pick it up correctly. &nbsp;We grumble GOOD. &nbsp;You then hammer the nail sideways so its not straight. &nbsp;We SIGH and MOAN. &nbsp;We say NOT LIKE THAT -- EINSTEIN -- STRAIGHT. &nbsp;I have no idea why I hired you as an apprentice. &nbsp;Then we take the nail out and give you new one and say TRY AGAIN. &nbsp;You do it right. &nbsp;We say GOOD. &nbsp;Now do FIFTY MORE JUST LIKE IT. &nbsp;And so you learn. &nbsp;And you probably don't forget.&nbsp;</p>

<p>With a book we can't really have that interaction.&nbsp;</p>

<p>With an electronic course we think we can and we are eager to try. &nbsp;We think a lot of people could learn programming if they were taught this way and we think a typical book sort of bores a lot of people or confuses them and they just give up or decide not to try. &nbsp;So give it a try and send us feedback so we can refine the course -- but over time we think it'll be a success.&nbsp;</p>

<p>Ready for your first nail to hammer? &nbsp;Good because that is what we are going to do. &nbsp;We are going to do one problem in this e-course and only one and we are going to work with you to make it so you absolutely know how to do it. &nbsp;We have picked the game of blackjack for this course as its one of the first programs that one of the authors was asked to write when he took an intro to computer science course and he loved it and it made it so all he wanted to do was study computer science. &nbsp;So if it worked for him -- well then maybe it'll work for you. &nbsp;</p>

<p>So first you have to know how to play black jack. &nbsp;Its a card game. &nbsp;There are 52 cards in a deck and they have numbers &nbsp;on them. &nbsp;If you have never seen a deck of cards then follow</p>

<div data-nickname="dagr1234" data-type="comment">
<div class="comment-identifier" contenteditable="false"><img src="https://secure.gravatar.com/avatar/aac3dd6128e307df756933f6a5be9e1f" />
<div spellcheck="false">dagr1234</div>
<i class="delete_comment glyphicons remove_2">&nbsp;</i></div>
this link</div>
</section>
</section>

<p>&nbsp;</p>

<section class="pagenumrestart" data-type="chapter" xmlns="http://www.w3.org/1999/xhtml">
<section data-type="sect1">
<div data-nickname="dagr1234" data-type="comment">
<p>&nbsp;</p>
</div>

<p>&nbsp;to read about decks of cards. &nbsp;Anyway its played between one player and &nbsp;a dealer. &nbsp;There are different versions but we are going to make this one simple.&nbsp;</p>

<p>The dealer deals two cards to a player and one card to the dealer. &nbsp;The dealer shows the player his/her card (for the rest of this course we are calling the dealer a HE but we don't care what gender the dealer is). &nbsp;</p>

<p>The rule is the player wins if the player does not go over 21. &nbsp; Face cards (e.g.; J, Q, K) count as 10 and the Ace counts as 1 or 11. &nbsp; If 11 makes you go over 21, then count the Ace as a one.&nbsp;</p>

<p>So the player gets to decide, HIT or STAND at this point. &nbsp;If the player says HIT they get another card. &nbsp;If the player's total goes over 21 well then they lose immediately. &nbsp;If the number is under 21, the player can decide HIT OR STAND again. &nbsp;So lets say the player is dealt a 5 and 2. &nbsp;The player has a total of 7. &nbsp;The players says HIT and gets a 10 and then the player says STAND. &nbsp;Now the player has a total of 17. &nbsp;The dealer now makes no decisions and must follow strict rules. &nbsp;Up to a 16 the dealer takes a HIT and at 17 and above dealer stands. &nbsp;So lets say the dealer on the first card has a 10. &nbsp;Dealer, by rule, takes a HIT and gets an 8. &nbsp;Total is 18. &nbsp;Dealer by rule stands as its over 16 and so the dealer's total is compared to the player's total. &nbsp;Dealer has 18, player has 17 and player loses. &nbsp;Note, if the dealer had gone over 21 with a HIT, they lose immediately. &nbsp; &nbsp;In a casino, the player loses the money they have bet on the hand. &nbsp; &nbsp;And so the game continues until the player has run out of money or has won enough to win. &nbsp;We hate to bring you into a life of gambling with this e-course, but its an awfully good game to learn how to program. &nbsp;It also allows for a lot of incremental improvements that we can make over time. &nbsp;So in our master-apprentice model you can start building the basic house (e.g.; game of blackjack) and then we can add a fancier roof or put in a special kitchen, etc. &nbsp;</p>

<p>Time for your first nail.&nbsp;</p>

<p>When the user tells the computer I WANT TO PLAY BLACKJACK -- we want to start the game and say HELLO to the user and remind them of the basics of the rules. &nbsp;</p>

<p>In Ruby the way to show the user something is with the command&nbsp;<strong>puts&nbsp;</strong>(put string).&nbsp;</p>

<p>&nbsp;</p>

<p>Now click here and enter this into the ruby code editor that launches and type the following:</p>

<p>puts &quot;Welcome to Blackjack. &nbsp;Dealer will always hit on a 17, over 21 and you lose&quot;</p>

<p><span style="line-height: 1.5em;">Enter those this line and try it and see if the computer does the right thing. &nbsp;IF its works CONGRATULATIONS you have hammered your first nail. &nbsp;Remember to use double quotes around the rules (the key two to the right of the L key on your keyboard and you have to hit shift to get the quotes to display).</span></p>

<p>Now lets learn how picky this stuff can be.&nbsp;</p>

<p>Change one of the<strong> puts </strong>commands to <strong>put</strong>.&nbsp;</p>

<p>You'll get a great message:</p>

<p class="p1"><strong>NoMethodError: undefined method `put' for main:Object</strong></p>

<p>You'll get a nice message of &quot;NoMethodError: undefined method for put&quot;. &nbsp;So annoying that computers have to always care about every last little letter. &nbsp; &nbsp;Notice that its speaking greek immediately. &nbsp; Well first it tells you the type of error you have followed by a colon. &nbsp;In this case you got yourself a nice NoMethodError. &nbsp; What on earth is a method and why in heavens is it bad to not have one? &nbsp;</p>

<p>Well it turns out a method is piece of code that you might want to repeat. &nbsp;Terrific name isn't it. &nbsp; Some languages call it a function. &nbsp;Bet that doesn't help either, but if you remember in math, functions are used to make life easier to express equations. &nbsp;You could say y = x + 2 but if you define a function on x you'd have f(x) = x + 2 and then you could then say y &nbsp;= f(x) . &nbsp;For really long equations y=f(x) is way easier to look at then the whole equation.</p>

<p>Anyway, &nbsp;you simplify your computer programs with methods and we'll get to all that later. &nbsp;We just wanted you to know its a thing that comes in handy to make it so you don't have to write the same programming code over and over. So Ruby has a way to make it so you can define new methods. &nbsp;When you entered <strong>puts</strong>, that actually referenced a method the people who invented ruby built to output whatever you put &nbsp;in quotes to the screen. &nbsp;</p>

<p>When you got rid of the S, the ruby interpreter (the thing that processes each Ruby command) decided you must have written your own grand method called PUT and it looked for it. &nbsp;It couldn't find it so it threw up its hands and said, HEY you must be so SMART that you have written your very own method and now sadly I can't find it. &nbsp;</p>

<p>Now fix your PUT to PUTS and get it to work again. &nbsp;</p>

<p>Now lets break something else. &nbsp;Lets get rid of the double quotes.&nbsp;</p>

<p>so your code will now look like</p>

<p>puts Welcome to Blackjack. &nbsp;Dealer will always hit on a 17, over 21 and you lose</p>

<p>Now you get a nice error message</p>

<p class="p1"><strong>NameError: undefined local variable or method `blackjack' for main:Object</strong></p>

<p>Aren't you glad you are doing this with such friendly error messages? &nbsp;Well now the Ruby interpreter says you entered PUTS correctly so it was thinking you would follow it with a nice piece of text in quotes so that Ruby (and a lot of other languages) would think you were referring to a thing called a STRING. &nbsp;A STRING is a type of data that can be output nicely to the screen and it can include numbers and letters. &nbsp;You can't do math on a string like ask the computer to divide one string by another string.&nbsp;</p>

<p>The truth is the Ruby interpreter when using the&nbsp;<strong>puts&nbsp;</strong>method looks for a variable that is of type STRING to come next. &nbsp;</p>

<p>So you could say puts &quot;hello&quot; and that assigns &quot;hello&quot; to a variable (a thing that hold different values over time) and then displays it.&nbsp;</p>

<p>if you said&nbsp;</p>

<p>x = &quot;hello&quot;</p>

<p>puts x</p>

<p>that will assign &quot;hello&quot; to the variable named x and then output x.&nbsp;</p>

<p>When you took off the quotes around Welcome to blackjack -- ruby thought you were referring to a variable named WELCOME. &nbsp;It thought somewhere you must have been smart enough to assign it a value. &nbsp;So it looked in its entire lexicon of variables for welcome and didn't find it so it gave you a NAME ERROR thinking you must have mis-spelled the variable. &nbsp;Then it said undefined local variable. &nbsp; In Ruby you can use a method to obtain values so either a variable or method would work so it went ahead and looked for methods named blackjack as well. &nbsp;It didn't find one so it said &quot;undefined local variable or method&quot; then it was nice enough to tell you what it couldn't find -- it was hunting for blackjack and it didn't find it and so it even told you what it was hunting for (and we just put it in italix).&nbsp;</p>

<p><strong>NameError: undefined local variable or method <em>`blackjack' </em>for main:Object</strong></p>

<p>Ruby uses a thing called OBJECTS and they are just containers that &nbsp;contain methods and variables -- we'll be using them for various things in the game. &nbsp;CARD, DEALER, PLAYER are all good objects, but we'll &nbsp;talk more about that later.&nbsp;</p>

<p>Anyway the Ruby interpreter hunted in the current object called MAIN and couldn't find anything so it told you where it was looking in main:object.&nbsp;</p>

<p>So the Ruby interpreter spat out a bunch of gibberish but if you take a deep breath and read it slowly it can often contains hints on how to fix things. &nbsp;Most people new to programming see an error message and it has stuff in it that makes zero sense and so they just skip it and ask the teacher how to fix the problem. &nbsp;As your MASTER and you as APPRENTICE we now COMMAND you to READ EVERY ERROR MESSAGE TEN TIMES before doing anything else. &nbsp;Read it slowly. &nbsp;Trust us, it'll make you far more productive. &nbsp;</p>

<p>Anyway, fix your program, put the quotes back and get it to work again.</p>

<p>&nbsp;</p>

<p>Ready for your next nail?</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p class="p1">&nbsp;</p>

<p>&nbsp;</p>

<div data-nickname="dagr1234" data-type="comment">
<div class="comment-identifier" contenteditable="false"><img src="https://secure.gravatar.com/avatar/aac3dd6128e307df756933f6a5be9e1f" />
<div spellcheck="false">dagr1234</div>
<i class="delete_comment glyphicons remove_2">&nbsp;</i></div>

<p>Maybe have a link to the rest of this chapter here as background -- its got good stuff in it but not sure we need it in the dialog of this e-course.</p>
</div>

<p><span style="line-height: 1.5em;">Computer science is never tied to a programming language; it is tied to the task of solving problems efficiently using a computer. A computer comes with some resources, which will be discussed in , such as internal memory for short-term storage, processing capability, and long-term storage devices. A </span><em style="line-height: 1.5em;">complete program</em><span style="line-height: 1.5em;"> is a set of instructions that use the computer to solve a real problem. The tool for producing these instructions is called a </span><em style="line-height: 1.5em;">programming language</em><span style="line-height: 1.5em;">. The goal is to develop solutions that use these resources efficiently to solve real problems.</span></p>

<p>Programming languages come and go, but the essence of computer science stays the same. If we need to sort a sequence of numbers, for example, it is immaterial if we sort them using programming language A or B. The steps the program will follow, commonly referred to as the <em>algorithm</em>, will remain the same. Hence, the core goal of computer science is to study algorithms that solve real problems. Computer scientists strive to create a correct sequence of steps that minimize resource demands, operate in a timely fashion, and yield correct results.</p>

<p>Algorithms are typically specified using pseudocode. Pseudocode, which may itself be simply written in plain language, specifies the logical, conceptual steps that must occur without specifying the necessary details needed to actually execute each step. However, we think that a properly selected subset of Ruby is sufficiently simple to introduce the algorithms. So, instead of creating an algorithm by writing it in plain language, generating equivalent pseudocode, and transforming it into a programming language, we go straight from the plain-language definition of an algorithm to Ruby code.</p>
</section>

<section data-type="sect1" id="onedot2_application_development">
<h1>1.2 Application Development</h1>

<p>When writing a program, it is important to keep in mind that the computer will do exactly what you tell it to do. It cannot think as a human would, so you must provide clear instructions for every step.</p>

<p>When giving instructions to others, people will often fill in blanks in logic without even realizing it. For example, if you instruct someone to &acirc;go to the bank,&acirc; you may not say what mode of transportation should be used. A computer, however, does not have the ability to &acirc;fill in the blanks.&acirc; A computer will only do exactly what you tell it to do.</p>

<p>Imagine, for example, explaining to a person and to a computer how to make a peanut butter and jelly sandwich. To the person, all you might need to say is, &acirc;Spread the peanut butter on one slice of bread, the jelly on the other slice of bread, and then put the pieces of bread together.&acirc; If these instructions were given to a computer, however, the computer would not know where to start. Implied in these instructions are many logical steps that a human can automatically infer and the computer cannot. For example, the human would know that the jar must first be opened to scoop peanut butter out before you can spread it onto a slice of bread. The computer might try to spread the actual jar across the bread, without taking the peanut butter or jelly out&acirc;assuming it could even find them!</p>

<p>Computer science is ultimately about problem solving. The following is a basic approach to solving problems:</p>

<ul class="simplelist">
	<li>Step 1: Understand the problem.</li>
	<li>Step 2: Write out a solution in plain language.</li>
	<li>Step 3: Translate the language into code.</li>
	<li>Step 4: Test the code in the computer.</li>
</ul>

<section data-type="sect2" id="step_1_understanding_the_problem">
<h2>Step 1: Understand the Problem</h2>

<p>During this step, you try to answer all questions about the problem at hand. For example, you may be asked to create a program that stores a list of names, like a directory. Instead of just creating this program with little forethought, it is important to know all the details of the problem. Here are some examples:</p>

<ul>
	<li>
	<p>How many names will be stored?</p>
	</li>
	<li>
	<p>Do first and last names need to be stored separately?</p>
	</li>
	<li>
	<p>Are middle names needed?</p>
	</li>
	<li>
	<p>What is the maximum length that a name can be?</p>
	</li>
</ul>
</section>

<section data-type="sect2" id="step_2_write_out_the_solution_in_plain_l">
<h2>Step 2: Write Out the Solution in Plain Language</h2>

<p>Once the problem is understood, the next step is to write an outline of how you will solve it. An example of the process of storing a name might look like a sequence of sentences:</p>

<table>
	<tbody>
		<tr>
			<td>
			<p>Ask for the first name.</p>
			</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>
			<p>Store the first name.</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Ask for the last name.</p>
			</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>
			<p>Store the last name.</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Optionally, ask for the middle initial.</p>
			</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>
			<p>Store the middle initial.</p>
			</td>
		</tr>
	</tbody>
</table>
</section>

<section data-type="sect2" id="step_3_translate_the_language_into_code">
<h2>Step 3: Translate the Language into Code</h2>

<p>Once the plain-language version is written, it is time to translate it into actual code. The Ruby code for the preceding example is shown in , but you are certainly not expected to understand it yet.</p>

<p>Note the pound sign (#) on the righthand side. This sign means that the remainder of the line is a <em>comment</em>. A comment is not part of the instructions given to the computer. That is, a comment is a nonexecutable segment of code. Typically, comments are used to explain what the code does. Not only is it critical to comment code for the sake of readability and understanding, but using comments is considered good programming style, and the liberal use of comments is essential. Always remember that you (or someone else) may have to fix errors&acirc;colloquially referred to as bugs&acirc;years after you write a program; comments will help you understand what your code does years after you initially wrote it.</p>

<div data-type="example" id="english_rarr_ruby_code">
<h5>Plain language &acirc; Ruby code</h5>

<pre class="pre " data-code-language="ruby" data-type="programlisting">
        1 puts &quot;Enter first name: &quot;	# Ask for the first name
        2 first_name = gets		# Store the first name
        3 puts &quot;Enter last name: &quot;	# Ask for the last name
        4 last_name = gets		# Store the last name
        5 puts &quot;Enter middle initial: &quot;	# Ask for the middle initial
        6 middle_initial = gets		# Store the middle initial
</pre>
</div>
</section>

<section data-type="sect2" id="step_4_test_the_code_in_the_computer">
<h2>Step 4: Test the Code in the Computer</h2>

<p>This step entails running the program you created and seeing that it runs properly. It is best to test portions of your code as you write them, instead of writing an entire program only to find out that none of it works.</p>
</section>
</section>

<section data-type="sect1" id="onedot3_algorithms">
<h1>1.3 Algorithms</h1>

<p>Algorithms are step-by-step methods of solving problems. The process of reading in names previously described is an example of an algorithm, though a very simple one. Some are extremely complicated, and many vary their execution depending on input. Often algorithms take input and generate output, but not always. However, all algorithms have something in common: they all do something.</p>

<div data-type="note" id="ch01note01">
<h1>Gem of Wisdom</h1>

<p>Algorithms are the core of computer science. Correct and efficient algorithms guarantee that the computer works smart rather than only hard. Thus, think about the problem, come up with a good algorithm, and then determine how many steps the computer needs to complete the task.</p>
</div>

<p>Imagine a website like Google Maps, which has an algorithm to get directions from one point to another in either North America or Europe. It typically requires two inputs: a source and a destination. It also gives two outputs: the narrative directions to get from the source to the destination, and a map of the route.</p>

<p>The directions produced are also an algorithm; they accomplish the task of getting from the source to the destination. Imagine getting the directions to your friend&acirc;s house shown on the map in .</p>

<ol>
	<li>
	<p>Start going south on River Road.</p>
	</li>
	<li>
	<p>Turn left (east) on Main Street.</p>
	</li>
	<li>
	<p>Take a right (south) on Ruby Lane.</p>
	</li>
	<li>
	<p>Turn left (east) toward Algorithm Circle.</p>
	</li>
	<li>
	<p>Continue until you come to 345 Algorithm Circle (your friend&acirc;s house).</p>
	</li>
</ol>

<figure id="directions_quotation_markalgorithmquotat" style="float: 0"><img src="images/cspr_0102.png" />
<figcaption>Directions &acirc;algorithm&acirc;</figcaption>
</figure>

<p>First notice that the directions are numbered; each step happens in sequential order. Additionally, it describes general steps like, &acirc;Turn left (east) on Main Street.&acirc; It does not say, &acirc;Turn on your left turn signal and wait for the light to turn green, and then turn left on Main Street.&acirc; That is not the point of an algorithm. An algorithm does not need to write out every single detail, but it needs to have all the important parts.</p>

<section data-type="sect2" id="onedot3dot1_algorithm_efficiency">
<h2>1.3.1 Algorithm Efficiency</h2>

<p>Different algorithms may accomplish the same task, but some will do it much faster than others. Consider the algorithm just described for going to your friend&acirc;s house, which certainly is not the only route to her or his home. Instead of getting on Ruby Lane, you could have hopped on the expressway, gone to the airport, and then taken a cab from the airport to your friend&acirc;s house&acirc;but that would be extremely inefficient. Likewise, there may be a more efficient route to your friend&acirc;s house than the one described. Just because you have created an algorithm does not make it efficient, and being able to create efficient algorithms is one of the factors that distinguishes a good computer scientist. For example, imagine receiving the following set of directions to your friend&acirc;s house instead of the ones shown in the previous section, illustrated on the map in :</p>

<ol>
	<li>
	<p>Start going south on River Road.</p>
	</li>
	<li>
	<p>Turn left (east) one block south of Main Street onto Algorithm Circle.</p>
	</li>
	<li>
	<p>Continue until you come to 345 Algorithm Circle (your friend&acirc;s house).</p>
	</li>
</ol>

<figure id="directions_quotation_markalgorit-id00001" style="float: 0"><img src="images/cspr_0103.png" />
<figcaption>Directions &acirc;efficient algorithm&acirc;</figcaption>
</figure>

<p>Here we use a different algorithm that accomplishes the same task, and it does so slightly more efficiently. That is, fewer turns are involved.</p>
</section>
</section>

<section data-type="sect1" id="onedot4_summary">
<h1>1.4 Summary</h1>

<p>You now understand the core foundations of computer science, namely the use of algorithms to solve real-world problems. Ruby, as used throughout the remainder of the book, is a powerful, yet relatively easy to understand, programming language that can be used to implement these algorithms. It is, however, critical to remember that independent of the programming language used, without a good algorithm, your solution will be ineffective.</p>

<section data-type="sect2" id="onedot4dot1_key_concepts">
<h2>1.4.1 Key Concepts</h2>

<ul>
	<li>
	<p>The essence of computer science is problem solving. Computer science involves using the computer as a tool to model or solve various problems, from storing names in a database to finding efficient directions to a friend&acirc;s house.</p>
	</li>
	<li>
	<p>When programming, it is important to understand that the computer is never wrong. It is merely following the directions you have given it.</p>
	</li>
	<li>
	<p>The following are basic steps for solving a computer science problem:</p>

	<ul class="simplelist">
		<li>Step 1: Understand the problem.</li>
		<li>Step 2: Write out a solution in plain language.</li>
		<li>Step 3: Translate the language into code.</li>
		<li>Step 4: Test the code in the computer.</li>
	</ul>
	</li>
	<li>
	<p>Algorithms are step-by-step methods for solving problems. When writing an algorithm, it is important to keep in mind the algorithm&acirc;s efficiency.</p>
	</li>
</ul>

<div data-type="note" id="ch01note02">
<h1>Gem of Wisdom</h1>

<p>Once we have an algorithm, we can compare it to other algorithms and pick the best one for the job. Once the algorithm is done, we can write a program to implement it.</p>
</div>
</section>

<section data-type="sect2" id="onedot4dot2_key_definitions">
<h2>1.4.2 Key Definitions</h2>

<ul>
	<li>
	<p><em>Algorithm:</em> A step-by-step method for solving problems.</p>
	</li>
	<li>
	<p><em>Algorithm efficiency:</em> A measurement that determines how efficient one algorithm is compared with another.</p>
	</li>
</ul>
</section>
</section>

<section data-type="sect1" id="onedot5_exercises">
<h1>1.5 Exercises</h1>

<ol class="qonly">
	<li>
	<p>Imagine that you are creating a pocket calculator. You have created the functionality for all the buttons except <em>x</em><sup>2</sup>, the button that squares a number, and <em>exp</em>, which allows you to calculate base<sup>exponent</sup>, where <em>exponent</em> is an integer. You may use any other functionality a calculator would normally have: for example, (+, -, *, /, =).</p>

	<ol type="a">
		<li>
		<p>Create the functionality for the <em>x</em><sup>2</sup> button.</p>
		</li>
		<li>
		<p>Create the functionality for the <em>exp</em> button.</p>
		</li>
	</ol>
	</li>
	<li>
	<p>In the third-grade math class of French mathematician Carl Gauss, the teacher needed to give the students some busywork. She asked the class to compute the sum of the first 100 numbers (1 to 100). Long before the rest of the class had finished. Carl raised his hand and told his teacher that he had the answer: 5,050.</p>

	<ol type="a">
		<li>
		<p>Craft an algorithm that will sum the first <em>n</em> numbers (assuming <em>n</em> &acirc;&yen; 1). How many steps does your algorithm take to complete when <em>n</em> = 100? How many steps does it take when <em>n</em> = 1,000?</p>
		</li>
		<li>
		<p>Can you create an algorithm like Gauss&acirc;s where the number of steps does not depend on <em>n</em>?</p>
		</li>
	</ol>
	</li>
	<li>
	<p>A palindrome is a word or phrase that reads the same way forward and backward, like &acirc;racecar.&acirc; Describe a sequence of steps that determines if a word or phrase is a palindrome.</p>
	</li>
	<li>
	<p>Consider the three mazes shown in . Describe two different algorithms for solving a maze. Discuss advantages and disadvantages of each algorithm. Then look at the maze and predict which algorithm will complete first. See if your predictions were correct by applying your algorithms to the mazes.</p>

	<figure id="three_mazes_em_dash_problem_1dot6" style="float: 0"><img src="images/cspr_0106.png" />
	<figcaption>Three mazes for Exercise 4</figcaption>
	</figure>
	</li>
	<li>
	<p>shows an alternative way to represent an algorithm. (Note: we introduce this construct in detail later on. If it looks too intimidating, skip it until after you&acirc;ve read .)</p>

	<ol type="a">
		<li>
		<p>Starting at the circle labeled &acirc;Start&acirc; work your way through the figure. What is the purpose of this algorithm?</p>
		</li>
		<li>
		<p>Translate the figure into simple language. Note that a diamond in the figure represents a condition that may be true or false.</p>
		</li>
	</ol>

	<figure id="algorithm_alternative_em_dash_problem_1d" style="float: 0"><img src="images/cspr_0104.png" />
	<figcaption>Alternative representation of an algorithm for Exercise 5</figcaption>
	</figure>
	</li>
	<li>
	<p>A cable company must use cables to connect 15 homes together so that every home is reachable by every other home. The company has estimated the costs of different cable routes ( shows the numbers associated with each link). One engineer provides an algorithm, shown in , that will find the cheapest set of routes to pick. Does the engineer&acirc;s algorithm work for this case? Why or why not?</p>

	<figure id="cable_company_dilemma_em_dash_problem_1d" style="float: 0"><img src="images/cspr_0105.png" />
	<figcaption>Cable company dilemma for Exercise 6</figcaption>
	</figure>

	<p><strong>Engineer&acirc;s Algorithm:</strong></p>

	<ol>
		<li>
		<p>Pick one cable route with the lowest cost not already picked. Add this route to the set of cheapest routes.</p>
		</li>
		<li>
		<p>Check if every house is connected to every other house through any series of cables. If it isn&acirc;t, go back to step 1. If every house is connected, then the cheapest set of routes has been found.</p>
		</li>
	</ol>
	</li>
</ol>
</section>
</section>

<p>&nbsp;</p>
